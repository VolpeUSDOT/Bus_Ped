---
title: "LADOT Bus Event-Route Association"
output: 
  html_document:
    self_contained: true
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: false
---

<!-- saved from url=(0014)about:internet -->
<!-- This needs to be manually added to the second line of the html -->

```{r setup, include=FALSE, message=F, warning=F}
knitr::opts_chunk$set(echo = F, warning=F, message=F)
options(width = 2400)
library(tidyverse)
library(maps) # for mapping base layers
library(rgdal)
library(rgeos) # for gDistance
library(DT) # for datatable
library(plotly) # do after ggplot2
# library(RgoogleMaps)
library(ggmap)
library(knitr)
library(kableExtra)
library(plyr) # for join of fortified data

codeloc = "~/git/Bus_Ped/Single_bus"
rootdir <- "//vntscex.local/DFS/3BC-Share$_Mobileye_Data/Data"
knitr::opts_knit$set(root.dir = rootdir)
```

```{r datainput, message=F, warning=F}
# If the prepared data are not in the working directory, run the prep script.
if(length(grep('Warning_Braking_15301.RData', dir())) == 0) {
  source(file.path(codeloc, "15301_braking.R")) 
  } else { 
    if(!exists("db")) load("Warning_Braking_15301.RData")
  }

# Load shapefiles
if(length(grep('LADOT_routes.RData', dir())) == 0) {
  source(file.path(codeloc, "Route_prep.R")) 
  } else { 
    if(!exists("dt_dash")) load("LADOT_routes.RData") 
  }

# Prep data frames as spatial
# Make it a spatial data frame, only picking out relevant columns
if(class(db) != "SpatialPointsDataFrame"){
  db$LocationTime = as.character(db$LocationTime)
  
  db = db %>% filter(!is.na(Latitude) & !is.na(Longitude))
  db <- SpatialPointsDataFrame(coords = db[c("Longitude","Latitude")], data = dplyr::rename(db, ll.lat = Latitude, ll.lon = Longitude),
                               proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
  
  db.ll = db
  db <- spTransform(db, CRS(proj))
  
  # Add hard braking
  b_df <- b; class(b_df) = 'data.frame'

  b_s <- SpatialPointsDataFrame(coords = b_df[c("Longitude", "Latitude")],
                                data = dplyr::rename(b_df, ll.lat = Latitude, ll.lon = Longitude),
                                 proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
  
  b_s.ll = b_s
  b_s <- spTransform(b_s, CRS(proj))
  
  }
```

# Overview

The goal of this document is to detail the process of associating events from buses outfitted with Mobileye Shield+ systems to specific routes. The Sheild+ system returns warnings for different types of possible pedestrian collisions, and also records hard braking events. Bus route information is not reliably associated with individual events in the data available, so this work associates those events with specific routes.


## Data 

### Events

RoscoLive / Ituran

*(add detail on what warnings and brakings are)*

Warning Events:  
+ PCW-LF
+ PCW-LR
+ PCW-RR
+ PDZ - Left Front
+ PDZ-LR
+ PDZ-R
+ ME –Pedestrian Collision Warning
+ ME – Pedestrian In Range Warning

Braking Events: 
+ Safety - Braking – Aggressive
+ Safety - Braking – Dangerous

```{r dataexplore}

cnt <- plyr::count(db$StatusName)
db$StatusOrder <- factor(db$StatusName, 
  levels = cnt$x[order(cnt$freq, decreasing = TRUE)])

ggplot(db@data, aes(x = StatusOrder) ) + geom_bar() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  ylab("Count of events") + xlab("Event StatusName") +
   scale_y_continuous(label=scales::comma) +
  ggtitle("Count of telematics events for Bus 15301, Jan-Aug 2018")

# ggsave("Event_count.jpg")
```

### Routes

Route shapefiles were accessed from the LA City GeoHub website. There are three three systems of bus routes: 

- [Community DASH](http://geohub.lacity.org/datasets/community-dash-routes)
- [Downtown DASH](http://geohub.lacity.org/datasets/downtown-dash-routes)
- [Metro Bus lines](http://geohub.lacity.org/datasets/metro-bus-lines)

## Visual association

As a first pass, we present a visual demonstration that braking events do align with routes:

```{r firstplots, eval = F}
colz = rainbow(nrow(dt_dash@data), alpha = 0.5)

plot(dt_dash[dt_dash@data$RouteNameS == "A",],
     col = colz[1],
     lwd = 2.5,
     ylim = as.vector(bbox(dt_dash)["y",]),
     xlim = as.vector(bbox(dt_dash)["x",])
     )

for(i in 2:nrow(dt_dash@data)){
  plot(dt_dash[dt_dash@data$RouteNameS == dt_dash@data$RouteNameS[i],],
       col = colz[i],
       add = T,
       lwd = 2.5
  )
  }

plot(b_s[b_s@data$StatusName=="Safety - Braking - Aggressive",], add = T,
     pch = "+")

plot(b_s[b_s@data$StatusName=="Safety - Braking - Dangerous",], add = T,
     pch = 15)

legend("topleft",
       col = c(colz, 1,1),
       pch = c(rep(NA, 5), 3, 15),
       legend = c(as.character(dt_dash$RouteName), "Aggressive Braking", "Dangerous Braking"),
       lwd =c(rep(2.5, 5), NA, NA),
       title = "Downtown DASH + Braking")
```


```{r firstplots_withmap, eval = T, include=F}

# bb = as.vector(bbox(dt_dash.ll))
bb = as.vector(bbox(db.ll))

# map_terrain_16 = get_stamenmap(bb, maptype = "terrain", zoom = 16)

if(length(grep("Basemaps", dir())) == 0){
#  map_terrain_15 = get_stamenmap(bb, maptype = "terrain", zoom = 15)
  
#  map_toner_hybrid_15 = get_stamenmap(bb, maptype = "toner-hybrid", zoom = 15)
  
#  map_toner_hybrid_14 = get_stamenmap(bb, maptype = "toner-hybrid", zoom = 14)
  
  map_toner_hybrid_13 = get_stamenmap(bb, maptype = "toner-hybrid", zoom = 13)
  
  map_toner_13 = get_stamenmap(bb, maptype = "toner", zoom = 13)

  map_toner_12 = get_stamenmap(bb, maptype = "toner", zoom = 12)
  
  save(list=c(#"map_terrain_15", "map_toner_hybrid_15","map_toner_hybrid_14",
              "map_toner_hybrid_13", "map_toner_13", "map_toner_12"), 
       file = "Basemaps.RData")
  } else { 
    load("Basemaps.RData") }

# ggmap(map_toner_hybrid_15) +
#   geom_point(data = b_s@data, aes(x = ll.lon, y = ll.lat)) 

# Fortify and join for plotting lines
dt_dash.df <- data.frame(id=rownames(dt_dash.ll@data),
                        values= length(dt_dash.ll),
                        dt_dash.ll@data, stringsAsFactors=F)

data_fort   <- fortify(dt_dash.ll)
dt_dash_merged <- join(data_fort, dt_dash.df, by="id")

#ggmap(map_toner_hybrid_14) +
ggmap(map_toner_12, extent  = "device") +
  geom_point(data = b_s@data, aes(x = ll.lon, y = ll.lat, shape = StatusName), color = "firebrick2") +
  geom_path(data = dt_dash_merged, aes(x = long, y = lat, color = RouteName), size = 1.2) +
  ggtitle("Downtown DASH + Braking, Bus 15301")

# ggsave("Downtown_DASH+Braking.jpg")

```

# Matching points to line

Goal is to replicate the manual process in ArcMap as follows:

- ArcToolbox > Proximity > Near
- Events as inputs
- Downtown DASH routes as near features

Output is two columns added to the Events file, one indicating which route is closest, other the distance to the nearest route in units of the projected data.

Here we use the `gDistance` between the points (first just braking, then all warning and brakings) and routes.
Output is route x warning matrix, with distances for all of them. 

```{r match_point_line}
# events = b_s is the SpatialPointsDataFrames version of the hard braking events
# events = db is the SpatialPointsDataFrames version of the all warning and braking events

if(length(grep("Braking_Dist.RData", dir(getwd())))==0){

  # Braking to downtown DASH
  dt_dash_dist_mat <- gDistance(b_s, dt_dash, byid=T)/1609.34 # convert to miles
  rownames(dt_dash_dist_mat) = dt_dash@data$RouteNameS[match(rownames(dt_dash_dist_mat), rownames(dt_dash@data))]
  dt_dash_route <- rownames(dt_dash_dist_mat)[apply(dt_dash_dist_mat, 2, function(x) which(x == min(x)))]
  dt_dash_dist <- apply(dt_dash_dist_mat, 2, min)
  
  
  # Braking to community DASH
  co_dash_dist_mat <- gDistance(b_s, co_dash, byid=T)/1609.34 # convert to miles
  rownames(co_dash_dist_mat) = co_dash@data$RouteNameS[match(rownames(co_dash_dist_mat), rownames(co_dash@data))]
  co_dash_route <- rownames(co_dash_dist_mat)[apply(co_dash_dist_mat, 2, function(x) which(x == min(x)))]
  co_dash_dist <- apply(co_dash_dist_mat, 2, min)
  
  # Braking to metro
  metro_dist_mat <- gDistance(b_s, metro, byid=T)/1609.34 # convert to miles
  rownames(metro_dist_mat) = metro@data$RouteNumbe[match(rownames(metro_dist_mat), rownames(metro@data))]
  metro_route <- unlist(lapply(apply(metro_dist_mat, 2, function(x) which(x == min(x))), function(x) names(x[1]))) # getting one route if multiple possible
  metro_dist <- apply(metro_dist_mat, 2, min) 
  
  b_d <- data.frame(b_s@coords, b_s@data, dt_dash_route, dt_dash_dist, co_dash_route, co_dash_dist, metro_route, metro_dist)
  save(b_d, file = "Braking_Dist.RData")
  write.csv(b_d, file = "Braking_Dist.csv", row.names = F)
  } else { load("Braking_Dist.RData") }

if(length(grep("Event_Dist.RData", dir(getwd())))==0){

  # Event to downtown DASH
  dt_dash_dist_mat <- gDistance(db, dt_dash, byid=T)/1609.34 # convert to miles
  rownames(dt_dash_dist_mat) = dt_dash@data$RouteNameS[match(rownames(dt_dash_dist_mat), rownames(dt_dash@data))]
  dt_dash_route <- unlist(lapply(apply(dt_dash_dist_mat, 2, function(x) which(x == min(x))), function(x) names(x[1]))) 
  dt_dash_dist <- apply(dt_dash_dist_mat, 2, min)
  
  
  # Event to community DASH
  co_dash_dist_mat <- gDistance(db, co_dash, byid=T)/1609.34 # convert to miles
  rownames(co_dash_dist_mat) = co_dash@data$RouteNameS[match(rownames(co_dash_dist_mat), rownames(co_dash@data))]
  co_dash_route <- unlist(lapply(apply(co_dash_dist_mat, 2, function(x) which(x == min(x))), function(x) names(x[1]))) 
  co_dash_dist <- apply(co_dash_dist_mat, 2, min)
  
  # Event to metro
  metro_dist_mat <- gDistance(db, metro, byid=T)/1609.34 # convert to miles
  rownames(metro_dist_mat) = metro@data$RouteNumbe[match(rownames(metro_dist_mat), rownames(metro@data))]
  metro_route <- unlist(lapply(apply(metro_dist_mat, 2, function(x) which(x == min(x))), function(x) names(x[1]))) # getting one route if multiple possible
  metro_dist <- apply(metro_dist_mat, 2, min) 
  
  db_d <- data.frame(db@coords, db@data, dt_dash_route, dt_dash_dist, co_dash_route, co_dash_dist, metro_route, metro_dist)
  
  
  save(db_d, file = "Event_Dist.RData")
  write.csv(db_d, file = "Event_Dist.csv", row.names = F)
  
  rm(metro_dist_mat, co_dash_dist_mat, dt_dash_dist_mat,
     metro_dist, co_dash_dist, dt_dash_dist)
  
  } else { load("Event_Dist.RData") }


```


```{r processtoclosest}

# Process to nearest route for each individual event
  
min.dist.route.num <- apply(db_d[,c("dt_dash_dist","co_dash_dist","metro_dist")], MARGIN = 1, which.min)
  
min.dist.route.id <- db_d[,c("dt_dash_route","co_dash_route","metro_route")] 
for(i in 1:ncol(min.dist.route.id)){ min.dist.route.id[,i] = as.character(min.dist.route.id[,i]) }

route_id = vector()
for(i in 1:nrow(min.dist.route.id)){
     route_id = c(route_id, min.dist.route.id[i, min.dist.route.num[i]])
    }
  
bus.system = c("Downtown DASH", "Community DASH", "Metro Bus Line")[min.dist.route.num]

db_d <- data.frame(db_d, nearest.route = route_id, bus.system)

save(db_d, file = "Event_Dist_Nearest.RData")
write.csv(db_d, file = "Event_Dist_Nearest.csv", row.names = F)

```




```{r process.trips}
# Process within day and hour
# table(db_d$day, db_d$nearest.route)
# Within each day and hour, apply the majority of route/system to each event.
# length(unique(dayhr)) = 1781 combinations of day and hour
db_d$dayhr <- paste(db_d$day, db_d$hour, sep = ".")

maj.nearest.route <- maj.bus.system <- confidence <- vector()

counter = 1
starttime = Sys.time()

for(i in unique(db_d$dayhr)){ # i = unique(dayhr)[5]# [sample(1:length(unique(dayhr)), 5)]
  dx <- db_d[db_d$dayhr == i,]
  
  dxx <- sort(table(dx$nearest.route), decreasing = T)
  dxx <- dxx[dxx != 0]
  
  dx2 <- sort(table(dx$bus.system), decreasing = T)
  dx2 <- dx2[dx2 != 0]

    
  maj.nearest.route = c(maj.nearest.route, names(dxx[1]))
  maj.bus.system = c(maj.bus.system, names(dx2[1]))
  confidence = c(confidence, dxx[1]/sum(dxx))

  if(counter %% 500 == 0) cat(counter, " . ")
  counter = counter + 1
  }
timediff = Sys.time() - starttime
cat(round(timediff, 2), attr(timediff, "units"), "elapsed \n")

maj.res <- data.frame(dayhr = unique(db_d$dayhr), maj.nearest.route, maj.bus.system, confidence)

db_2 <- left_join(db_d, maj.res, by = "dayhr")

save(db_2, file = "Event_Dist_Nearest_byHour.RData")
write.csv(db_2, file = "Event_Dist_Nearest_byHour.csv", row.names = F)


```



```{r process.trips.hourblock}

# Process within day and hour block
# table(db_d$day, db_d$nearest.route)

# Within each day and 3-hour time block, apply the majority of route/system to each event.
# length(unique(db_2$dayhr.block)) = 748 combinations of day and hour
hrblock <- cut(db_2$hour, breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24), include.lowest = T)

db_2$dayhr.block <- paste(db_2$day, hrblock, sep = ".")

maj.nearest.route.block <- maj.bus.system.block <- confidence.block <- vector()

counter = 1
starttime = Sys.time()

for(i in unique(db_2$dayhr.block)){ # i = unique(db_2$dayhr.block)[1]# [sample(1:length(unique(db_2$dayhr.block)), 5)]
  dx <- db_2[db_2$dayhr.block == i,]
  
  dxx <- sort(table(dx$nearest.route), decreasing = T)
  dxx <- dxx[dxx != 0]
  
  dx2 <- sort(table(dx$bus.system), decreasing = T)
  dx2 <- dx2[dx2 != 0]

  maj.nearest.route.block = c(maj.nearest.route.block, names(dxx[1]))
  maj.bus.system.block = c(maj.bus.system.block, names(dx2[1]))
  confidence.block = c(confidence.block, dxx[1]/sum(dxx))

  if(counter %% 500 == 0) cat(counter, " . ")
  counter = counter + 1
  }
timediff = Sys.time() - starttime
cat(round(timediff, 2), attr(timediff, "units"), "elapsed \n")

maj.res <- data.frame(dayhr.block = unique(db_2$dayhr.block), maj.nearest.route.block, maj.bus.system.block, confidence.block)

db_3 <- left_join(db_2, maj.res, by = "dayhr.block")

save(db_3, file = "Event_Dist_Nearest_byHourBlock.RData")
write.csv(db_3, file = "Event_Dist_Nearest_byHourBlock.csv", row.names = F)


```


```{r checkoutput_all}

# Checking output
kable(db_2 %>% select(ll.lat, ll.lon, dt_dash_route, dt_dash_dist, co_dash_route, co_dash_dist, metro_route, metro_dist, nearest.route, bus.system, maj.nearest.route, maj.bus.system, confidence) %>% sample_n(size = 5), caption="Distance (in miles) between five selected events and Downtown DASH routes") %>% kable_styling(bootstrap_options = c("striped", "hover"))


```


Checking output for a given day, looking at the individual event, hour, and hour-block route assignment results. Can filter by day and hour, and look to see how consistency of route assignment rises from 'nearest.route' to 'maj.nearest.route' (majority rule, by hour) to 'maj.nearest.route.block' (majority rule, by hour block).

Confidence shows the proportion of times within that time period (for majority rule assigment) that the designated route appeared. For example, if 10 events occurred within one hour, and 8 of the 10 were closest to Downtown Dash Route A

```{r checkoutput_day}
# 
# datatable(db_3 %>% 
#             select(#ll.lat, ll.lon, 
#                     day, hour, dt_dash_route, dt_dash_dist, co_dash_route, co_dash_dist, metro_route, metro_dist, nearest.route, bus.system, 
#                           maj.nearest.route, maj.bus.system, confidence,
#                           maj.nearest.route.block, maj.bus.system.block, confidence.block) %>%
#             filter(day > 50 & day < 75), 
#   caption = "Route assignment output. Distances in miles",
#           rownames = T,
#           options = list(dom = "ftp",
#                          #order = list(list(5, 'desc')),
#                          pageLength = 20)
#           ) %>% formatCurrency(c(4, 6, 8), currency = "", digits = 4)

kable(db_3 %>% 
            select(#ll.lat, ll.lon, 
                    day, hour, nearest.route, bus.system, 
                          maj.nearest.route, maj.bus.system, confidence,
                          maj.nearest.route.block, maj.bus.system.block, confidence.block) %>%
            filter(day == 96),
      caption="Route assignment output for one day")  %>% kable_styling(bootstrap_options = c("striped", "hover"))

datatable(db_3 %>% 
            select(#ll.lat, ll.lon, 
                    day, hour, nearest.route, bus.system, 
                          maj.nearest.route, maj.bus.system, confidence,
                          maj.nearest.route.block, maj.bus.system.block, confidence.block) %>%
            filter(day > 50 & day < 75), 
  caption = "Route assignment output.",
          rownames = T, 
          filter = 'top',
          options = list(#dom = "ftp",
                         #order = list(list(5, 'desc')),
                         pageLength = 10)
          ) %>% formatCurrency(c(7, 10), currency = "", digits = 2)

```

Histograms of confidence by hour and hour block. When using three-hour time blocks, some of the low-confidence route assignments disappear, but average confidence is similar between the two methods.


```{r confidence_hist}
ggplot(db_3) + 
  geom_histogram(aes(confidence)) +
  theme_bw() +
  ggtitle("Route assignment confidence using single hour blocks within a day")

ggplot(db_3) + 
  geom_histogram(aes(confidence.block), xlim = c(0, 1)) +
  theme_bw() +
  ggtitle("Route assignment confidence using three-hour blocks within a day")


```

